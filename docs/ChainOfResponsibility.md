### 动机

* 在软件构建过程中，一个请求可能被多个对象处理，但是每个请求在运行时只能有一个接受者，如果显式指定，将必不可少地带来请求发送者与接受者的紧耦合。
* 如何使请求的发送者不需要指定具体的接受者？ **让请求的接受者自己在运行时决定来处理请求，从而使两者解耦** 。

### 案例

比如界面中有各种各样的组件，那事件会随着组件之间的层级链条一层层往上传播

### 模式定义

使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。

### 结构

![](./images/ChainofResponsibility.png)

### 要点总结

* 职责链模式的应用场合在于“一个请求可能有多个接受者，但最后只能有1个接受者”，这时候请求发送者与接受者的耦合有可能出现“变化脆弱”的症状，职责链的目的是将二者解耦，从而更好地应对变化
* 应用职责链模式后，对象的职责分派将更灵活。我们可以在运行时行时动态添加/修改请求的处理职责
* 如果请求机制传递到职责链末尾仍得不到处理，应该有一个合理的缺省机制。这也是每一个接受对象的责任，而不是请求发送者的责任
* 注：该模式现在有点点过时，应用不多

### 代码

https://github.com/chouxianyu/design-patterns-cpp/tree/master/ChainOfResponsibility
